{"./":{"url":"./","title":"前言","keywords":"","body":".Net Core .NET Core 是开放源代码通用开发平台，由 Microsoft 和 .NET 社区在 GitHub 上共同维护。 它跨平台（支持 Windows、macOS 和 Linux），并且可用于生成设备、云和 IoT 应用程序。 https://docs.microsoft.com/zh-cn/dotnet/core/about .NET Core 具有以下特性： 跨平台： 可以在 Windows、macOS 和 Linux 操作系统上运行。 跨体系结构保持一致： 在多个体系结构（包括 x64、x86 和 ARM）上以相同的行为运行代码。 命令行工具： 包括用于本地开发和持续集成方案中的易于使用的命令行工具。 部署灵活： 可以包含在应用或已安装的并行用户或计算机范围中。 可搭配 Docker 容器使用。 兼容性：.NET Core 通过 .NET Standard与 .NET Framework、Xamarin 和 Mono 兼容。 开放源：.NET Core 是一个开放源平台，使用 MIT 和 Apache 2 许可证。 .NET Core 是一个 .NET * oundation 项目。 由 Microsoft 支持：.NET Core 由 Microsoft 依据 .NET Core 支持提供支持。 © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2018-12-10 20:13:55 "},"pages/uninstall.html":{"url":"pages/uninstall.html","title":".Net Core 安装卸载","keywords":"","body":".Net Core 安装卸载 作为新一代微软高效跨平台技术，.Net Core自诞生以来就是跨平台的，目前支持Windows/mac OS/Linux平台。 Linux发行版众多，截止到写这篇文档时，.Net Core 2.2支持的Linux发行版如下： RHEL Ubuntu 18.04 Ubuntu 16.04 Ubuntu 14.04 Debian 9 Debian 8 Fedora 28 Fedora 27 CentOS / Oracle openSUSE Leap SLES 1. 安装 .Net Core的安装异常简单。到官网下载安装即可。Windows和Mac中都是下载安装包，双击运行安装，不再赘述。Linux选择对应的发行版本，执行官方的安装命令即可。 提醒 Debian 9 安装.Net Core之前要先安装apt-transport-https（官方安装步骤遗漏了此步骤） $ sudo apt-get install apt-transport-https 如果想体验最新版的.Net Core的特性，则可以到.Net Core的Github项目中下载。这里有.Net Core所有版本，包括历史版本和预览版本。 https://github.com/dotnet/core/tree/master/release-notes .Net Core安装包分为Runtime和SDK。如果只期望在平台上运行.Net Core程序，安装Runtime包即可。如果希望在平台上使用.Net Core的高级功能，如开发调试等，则需要安装SDK包。SDK包含了Runtime。 2. 卸载 .Net Core在Windows卸载非常简单，直接在控制面板中卸载即可。至于Mac和Linux环境下卸载就比较麻烦了。由于安装文件比较分散，所以删除和清理工作也比较繁琐，幸好.NET Foundation提供了卸载脚本。 #!/usr/bin/env bash # # Copyright (c) .NET Foundation and contributors. All rights reserved. # Licensed under the MIT license. See LICENSE file in the project root for full license information. # DIR=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" && pwd )\" current_userid=$(id -u) if [ $current_userid -ne 0 ]; then echo \"$(basename \"$0\") uninstallation script requires superuser privileges to run\" >&2 exit 1 fi # this is the common suffix for all the dotnet pkgs dotnet_pkg_name_suffix=\"com.microsoft.dotnet\" dotnet_install_root=\"/usr/local/share/dotnet\" dotnet_path_file=\"/etc/paths.d/dotnet\" remove_dotnet_pkgs(){ installed_pkgs=($(pkgutil --pkgs | grep $dotnet_pkg_name_suffix)) for i in \"${installed_pkgs[@]}\" do echo \"Removing dotnet component - \\\"$i\\\"\" >&2 pkgutil --force --forget \"$i\" done } remove_dotnet_pkgs [ \"$?\" -ne 0 ] && echo \"Failed to remove dotnet packages.\" >&2 && exit 1 echo \"Deleting install root - $dotnet_install_root\" >&2 rm -rf \"$dotnet_install_root\" rm -f \"$dotnet_path_file\" echo \"dotnet packages removal succeeded.\" >&2 exit 0 使用以上脚本卸载即可。 如果对shell脚本不熟悉的小伙伴也可以使用以下命令快速卸载，以mac为例， $ curl -o uninstall.sh https://gist.githubusercontent.com/colin-chang/1d8da588f399165924dc62dad42598d8/raw/50444ab4db30ab8d6205216dec0c3983333a5d6b/dotnet-uninstall-pkgs.sh $ chmod -R 740 uninstall.sh $ sudo sh uninstall.sh $ rm uninstall.sh © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2018-12-11 18:34:57 "},"pages/deploy.html":{"url":"pages/deploy.html","title":".Net Core 部署","keywords":"","body":".Net Core 部署 .Net Core程序可以部署在Windows/Linux/mac平台上。Mac较多的用于开发，鲜少用做服务器环境。下面我们以Asp.Net Core为例，简单梳理一下。 .net core程序无论是调试还是发布版本，都建议在程序目录下运行命令，否则可能会出现静态资源文件无法访问的问题。 发布命令 dotnet publish -c Release 1. Linux 在Linux中也可以使用 dotnet ./your_app.dll 方式在终端中运行.Net Core程序，但是退出终端后，程序就停止了。我们可以将运行命令封装到一个Linux服务中，服务器启动后就可以在后台静默运行了。 systemd 可用于创建服务文件以启动和监视基础 Web 应用。 systemd 是一个 init 系统，可以提供用于启动、停止和管理进程的许多强大的功能。 创建服务文件 $ sudo vi /etc/systemd/system/lottery.service 服务文件示例 [Unit] # 服务描述 Description=Lottery [Service] # 工作目录，此处为.net core程序目录 WorkingDirectory=/home/colin/apps/content/lottery # dotnet核心命令 ExecStart=/usr/bin/dotnet /home/colin/apps/content/lottery/Lottery.WebApp.dll # 重启策略 Restart=always RestartSec=10 # 日志标识 SyslogIdentifier=dotnet-lottery # 用户 User=colin # 环境变量 Environment=ASPNETCORE_ENVIRONMENT=Production Environment=DOTNET_PRINT_TELEMETRY_MESSAGE=false [Install] WantedBy=multi-user.target 服务管理 # 启用服务 $ sudo systemctl enable lottery.service # 启动服务 $ sudo systemctl start lottery.service # 查看服务状态 $ sudo systemctl status lottery.service # 停止服务 $ sudo systemctl stop lottery.service # 重启服务 $ sudo systemctl restart lottery.service 完成以上步骤之后，Asp.Net Core程序已经挂载到了Kestrel服务器上并以Linux服务方式后台静默运行。虽然Kestrel服务器对Asp.Net支持非常好，但微软不建议其作为对外服务器，而是建议使用IIS/Nginx/Apache等作为代理服务器对外开放。 关于Linux下Nginx部署，参阅： http://colin-chang.site/book/linux/part2/nginx.html https://docs.microsoft.com/zh-cn/aspnet/core/host-and-deploy/linux-nginx?view=aspnetcore-2.2 Apache配置，参阅： https://docs.microsoft.com/zh-cn/aspnet/core/host-and-deploy/linux-apache?view=aspnetcore-2.2 2. Windows Windows 下.Net Core部署参阅： https://docs.microsoft.com/zh-cn/aspnet/core/host-and-deploy/iis/?view=aspnetcore-2.2 © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2018-12-10 20:18:12 "},"pages/dapper.html":{"url":"pages/dapper.html","title":"Dapper","keywords":"","body":"Dapper 全攻略 1. 简介 2. 项目/模型 3. CRUD 4. 其他 5. Dapper Plus 1. 简介 Dapper是.NET下一个轻量级的ORM框架，它和Entity Framework或Nhibnate不同，属于轻量级的，并且是半自动的。也就是说实体类都要自己写。它没有复杂的配置文件，一个单文件就可以了。Dapper通过提供IDbConnection扩展方法来进行工作。 Dapper没有定义特定的数据库要求，它支持所有ADO.NET支持的数据库，如SQLite,SQL CE,Firebird,Oracle,MySQL,PostgreSQL,SQL Server等。 国外知名网站Stack Overflow生产环境使用Dapper进行数据库访问。 2. 项目/模型 下面我们通过一个简单的.Net Core控制台项目来快速入门Dappper使用。数据库使用MySQL。 2.1 创建项目 # 创建.net core控制台项目 $ dotnet new console -n DapperDemo # 引用Dapper和MySQL nuget包 $ dotnet add package Dapper $ dotnet add package MySql.Data 2.2 数据模型 1) 数据库 CREATE TABLE `article` ( `Id` int(11) NOT NULL AUTO_INCREMENT, `Title` varchar(255) NOT NULL, `Content` text NOT NULL, `Status` int(1) NOT NULL DEFAULT '1', `UpdateTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP, `AuthorId` int(11) NOT NULL, PRIMARY KEY (`Id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `author` ( `Id` int(11) NOT NULL AUTO_INCREMENT, `NickName` varchar(255) NOT NULL, `RealName` varchar(255) NOT NULL, `BirthDate` date DEFAULT NULL, `Address` varchar(255) DEFAULT NULL, PRIMARY KEY (`Id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `comment` ( `Id` int(11) NOT NULL AUTO_INCREMENT, `ArticleId` int(11) NOT NULL, `Content` varchar(255) NOT NULL, `CreateTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`Id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 2) 数据模型 public abstract class BaseModel { public int Id { get; set; } } public class Author : BaseModel { public string NickName { get; set; } public string RealName { get; set; } public DateTime? BirthDate { get; set; } public string Address { get; set; } public Author() { } public Author(string nickName, string realName) { NickName = nickName; RealName = realName; } } public class Article : BaseModel { public string Title { get; set; } public string Content { get; set; } public ArticleStatus Status { get; set; } public DateTime UpdateTime { get; set; } public int AuthorId { get; set; } public Author Author { get; set; } public IEnumerable Comments { get; set; } } public class Comment : BaseModel { public int ArticleId { get; set; } public Article Article { get; set; } public string Content { get; set; } public DateTime CreateTime { get; set; } } public enum ArticleStatus { Abnormal, Normal } 3. CRUD 建立数据库连接。 private static readonly string _connStr; private static IDbConnection Cnn => new MySqlConnection(_connStr); static DapperPlus() { _connStr = \"Server=127.0.0.1;Database=db_dapper;Uid=root;Pwd=xxxxxx;\"; } 3.1 非查询操作 1) 插入数据 Dapper可以使用同样的方式插入一条或多条数据。 string sql = \"INSERT INTO author (NickName,RealName) VALUES(@nickName,@RealName)\"; var colin = new Author(\"Colin\", \"Colin Chang\"); var robin = new Author(\"Robin\", \"Robin Song\"); using (var cnn = Cnn) { await cnnExecuteAsync(sql, new Author[] { colin, robin }); } 2) 更新数据 string sql = \"UPDATE author SET Address=@address WHERE Id=@id\"; using (var cnn = Cnn) { await cnnExecuteAsync(sql, new { id = 1, address = \"山东\" }); } 3) 删除数据 string sql = \"DELETE FROM author WHERE Id=@id\"; using (var cnn = Cnn) { await cnnExecuteAsync(sql,new {id=2}); } 3.2 查询操作 1) 简单查询 var sql = \"SELECT * FROM author WHERE Id=@id\"; using (var cnn = Cnn) { var authors = await cnnQueryAsync(sql, new { id = 1 }); } 常用的IN ()方式查询 var sql = \"SELECT * FROM author WHERE Id IN @ids\"; using (var cnn = Cnn) { var authors = await cnnQueryAsync(sql, new { ids = new int[] { 1, 2 } }); } 2) 多表连接查询 此处演示使用三表连接查询，同时包含1:1和1:N的关系。 var sql = @\"SELECT * FROM article AS ar JOIN author AS au ON ar.AuthorId = au.Id LEFT JOIN `comment` AS c ON ar.Id = c.ArticleId\"; var articles = new Dictionary(); using (var cnn = Cnn) { var data = await cnnQueryAsync(sql, (article, author, comment) => { //1:1 article.Author=author; //1:N if (!articles.TryGetValue(article.Id, out Article articleEntry)) { articleEntry = article; articleEntry.Comments = new List{}; articles.Add(article.Id, articleEntry); } articleEntry.Comments.Add(comment); return articleEntry; }); // var result= data.Distinct(); } var result = articles.Values; //data.Distinct()和articles.Values都可以拿到数据，且数据内容相同。 1:N关系的连接查，查询出来的数据都是连接展开之后的全部数据记录，以上代码中的Lambda表达式会在遍历没条数据记录时执行一次。 3) 多结果集查询 Dapper支持多结果集查询，可以执行任意多条查询语句。 // 多结果集查询 string sqls = @\" SELECT * FROM article WHERE Id=@id; SELECT * FROM `comment` WHERE ArticleId=@articleId;\"; using (var cnn = Cnn) { var reader = await cnnQueryMultipleAsync(sqls, new { id = 1, articleId = 1 }); var articles = await reader.ReadAsync(); var comments= await reader.ReadAsync(); var article = articles.FirstOrDefault(); if (article != null) article.Comments = comments; } 多结果集查询中，配合使用多条存在一定关联关系的查询语句，可以在一定程上巧妙的实现连接查询的效果，避免多表连接查询锁表的问题。以上代码即实现了此种效果。 3. 事务和存储过程 3.1 事务 var scripts = new SqlScript[] { new SqlScript(\"UPDATE article SET UpdateTime=NOW() WHERE Id=@id\",new {id=2}), new SqlScript(\"UPDATE author SET BirthDate=NOW() WHERE Id=@id\",new {id=1}) } using (var cnn = Cnn) { IDbTransaction tran = null; try { cnnOpen(); tran = cnnBeginTransaction(); foreach (var script in scripts) await cnnExecuteAsync(script.Sql, script.Param, tran, commandType: script.CommandType); tran.Commit(); } catch { tran?.Rollback(); } } 以上演示用到的脚本模型类如下： public class SqlScript { public string Sql { get; set; } public object Param { get; set; } public CommandType CommandType { get; set; } public SqlScript(string sql, object param = null, CommandType cmdType = CommandType.Text) { Sql = sql; Param = param; CommandType = cmdType; } } 3.2 存储过程 Dapper完全支持存储过程。存储过程比较简单，代码就不展示了，读者可以自己按照自己想法随意创建。 using (var cnn = Cnn) { var users = cnnQuery(\"spGetAuthors\", new {Id = 1}, commandType: CommandType.StoredProcedure); } 使用传入传出参数的存储过程。 var p = new DynamicParameters(); p.Add(\"@a\", 11); p.Add(\"@b\", dbType: DbType.Int32, direction: ParameterDirection.Output); p.Add(\"@c\", dbType: DbType.Int32, direction: ParameterDirection.ReturnValue); using (var cnn = Cnn) { cnnExecute(\"spMagicProc\", p, commandType: CommandType.StoredProcedure); } int b = p.Get(\"@b\"); int c = p.Get(\"@c\"); 4. 其他 4.1 参数替换 Dapper支持对SQL语句中bool和数字类型进行替换。 var sql = \"SELECT * FROM article WHERE Status= {=Normal}\"; using (var cnn = Cnn) { var articles = await cnnQueryAsync(sql, new {ArticleStatus.Normal}); } 参数替换在特定类型字段中非常好用，比如\"category id\", \"status code\" or \"region\" 参数替换并非采用参数话查询，虽然使用方便但是建议经过测试后谨慎使用。 4.2 缓存查询 默认情况下Dapper会对执行SQL后的整个reader进行缓存，以减少数据库锁定和网络请求时间。然而执行大批量查询操作时缓存会占用大量内存空间，此时执行查询操作可以设置buffered: false 以禁用缓存。 4.3 ANSI编码 Dapper支持varchar类型参数,如果查询语句需要过滤一个varchar类型的字段可以使用以下方式指定编码: Query(\"select * from Author where Address = @address\", new {address = new DbString { Value = \"山东\", IsFixedLength = true, Length = 10, IsAnsi = true }); SQL Server中查询unicode and ANSI字段时务必使用unicode编码 4.4 多数据类型行 某些情况下同一行数据的某个字段可以是不同的数据类型。这种情况使用IDataReader.GetRowParser非常方便。 有shapes表结构如上图，我们可以根据Type字段将每行数据映射为Circle,Square,Triangle等具体类型对象。以下为示例代码： var shapes = new List(); using (var reader = connection.ExecuteReader(\"select * from Shapes\")) { // Generate a row parser for each type you expect. // The generic type is what the parser will return. // The argument (typeof(*)) is the concrete type to parse. var circleParser = reader.GetRowParser(typeof(Circle)); var squareParser = reader.GetRowParser(typeof(Square)); var triangleParser = reader.GetRowParser(typeof(Triangle)); var typeColumnIndex = reader.GetOrdinal(\"Type\"); while (reader.Read()) { IShape shape; var type = (ShapeType)reader.GetInt32(typeColumnIndex); switch (type) { case ShapeType.Circle: shape = circleParser(reader); break; case ShapeType.Square: shape = squareParser(reader); break; case ShapeType.Triangle: shape = triangleParser(reader); break; default: throw new NotImplementedException(); } shapes.Add(shape); } } 5. Dapper Plus Dapper仅提供了SqlHelper常用功能和对象映射，我们通常会对Dapper进行二次封装扩展以更方便的使用Dapper。 Dapper Plus扩展在无损Dapper性能的前提下，基本覆盖了日常数据操作。 Dapper Plus包含了上面的所有数据操作，案例中的代码已经包含在单元测试项目中。 源码地址：https://github.com/colin-chang/dapper-plus © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2018-12-10 20:13:55 "},"pages/https.html":{"url":"pages/https.html","title":"HTTPS","keywords":"","body":"全面 HTTPS 时代 1. HTTPS 简介 2. HTTPS 工作原理 3. HTTPS 现状分析 4. 免费升级到 HTTPS 5. GitHub Pages 自定义域名支持 HTTPS 1. HTTPS 简介 1) HTTP 的问题 认证网站 假如你正在访问支付宝，怎样确定你正在访问的是阿里巴巴提供的支付宝而不是假冒伪劣的钓鱼网站呢？ 数据安全 HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。 为了解决上面的问题，HTTPS出场了 👏👏👏 2) HTTPS 是什么 传输层安全性（TLS）是HTTPS的官方名称，你可能听说过它称为SSL（安全套接字层），SSL是已弃用的名称，TLS是一种加密协议，可通过计算机网络提供安全通信。 HTTPS是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL或TLS，HTTPS的安全基础是SSL/TLS。 HTTPS协议的主要作用有两个：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是认证网站的真实性。 2. HTTPS 工作原理 1) 主体对象 客户端。通常是浏览器(Chrome、IE、FireFox等)，也可以自己编写的各种语言的客户端程序。 服务端。一般指支持Https的网站，比如github、支付宝。 CA(Certificate Authorities)机构。Https证书签发和管理机构，比如Symantec、Comodo、GoDaddy、GlobalSign。 2) 工作流程 客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。 工作流程，基本分为三个阶段: 认证服务器。浏览器内置一个受信任的CA机构列表，并保存了这些CA机构的证书。第一阶段服务器会提供经CA机构认证颁发的服务器证书，如果认证该服务器证书的CA机构，存在于浏览器的受信任CA机构列表中，并且服务器证书中的信息与当前正在访问的网站（域名等）一致，那么浏览器就认为服务端是可信的，并从服务器证书中取得服务器公钥，用于后续流程。否则，浏览器将提示用户，根据用户的选择，决定是否继续。当然，我们可以管理这个受信任CA机构列表，添加我们想要信任的CA机构，或者移除我们不信任的CA机构。 协商会话密钥。客户端在认证完服务器，获得服务器的公钥之后，利用该公钥与服务器进行加密通信，协商出两个会话密钥，分别是用于加密客户端往服务端发送数据的客户端会话密钥，用于加密服务端往客户端发送数据的服务端会话密钥。在已有服务器公钥，可以加密通讯的前提下，还要协商两个对称密钥的原因，是因为非对称加密相对复杂度更高，在数据传输过程中，使用对称加密，可以节省计算资源。另外，会话密钥是随机生成，每次协商都会有不一样的结果，所以安全性也比较高。 加密通讯。此时客户端服务器双方都有了本次通讯的会话密钥，之后传输的所有Http数据，都通过会话密钥加密。这样网路上的其它用户，将很难窃取和篡改客户端和服务端之间传输的数据，从而保证了数据的私密性和完整性。 Https就是Http跑在SSL或者TLS上，所以本文讨论的原理和流程其实是SSL和TLS的流程，对于其它使用SSL或者TLS的应用层协议，本文内容一样有效。 3. HTTPS 现状分析 1) 优缺点分析 搞明白了Https的工作原理后，其优缺点就很容易理解了。 优点 尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，并且解决了网站认证的问题，这两点也正是我们在最开始提出的问题。另外，Google曾表示“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”，因此采用HTTPS的网站更有利于SEO. 缺点 HTTPS协议握手阶段比较费时，没有HTTP高效，且会使页面的加载时间延长近功耗增加； SSL证书收费 SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名。 2) 现状分析 了解了HTTPS的优缺点，我们再来看下其发展现状。 一般来说，很多公司都会直接购买由GlobalSign、GeoTrust、Verisign等全球公认的数字证书颁发机构颁发的SSL证书。购买？没错，大多数SSL证书都需要按年付费使用，而且价格不菲。过去HTTPS被认为比较低效。这也是前面提到的HTTPS的主要缺点。 但随着技术的发展，现在机器变得更快，已经解决了性能问题，Let's Encrypt等机构提供免费TLS证书，这两项发展改变了游戏，并使TLS成为主流。 3) 免费证书 Let's Encrypt 是一个免费、开放，自动化的证书颁发机构，由 ISRG（Internet Security Research Group）运作。ISRG 是一个关注网络安全的公益组织，其赞助商包括 Mozilla、Akamai、Cisco、EFF、Chrome、IdenTrust、Facebook等公司。ISRG 的目的是消除资金和技术领域的障碍，全面推进网站从HTTP到HTTPS过度的进程。 目前，包括FireFox、Chrome在内的主流浏览器都支持Let's Encrypt证书，已经有不少用户在真实项目中使用Let's Encrypt证书。Let's Encrypt免费SSL证书的有效期是90天，到期后可以再续期，这样也就可以变相长期使用了。 4. 免费升级到 HTTPS 一般的HTTPS使用流程如下。 Let’s Encrypt TLS 免费证书使用 Let’s Encrypt TLS证书可以自动化生成和更新，由于他们是免费的，所以没有理由不去做。相信大家也更关注免费证书如何使用，不多说，这就搞起来 😊😊😊 以下案例使用 Ubuntu 18.10/nginx 1.15.5 环境。 根据Let’s Encrypt 官网推荐，我们选择使用 Certbot ACME client 选择对应的软件和操作系统环境 参照网站给出的命令进行安装/配置/更新 证书 完成以上配置后，访问你的网站，不出意外已经升级到https了👍 自动配置完成之后的Nginx的配置文件形如： server { server_name localhost 104.199.230.207 bet518.win www.bet518.win; location / { proxy_pass localhost:5000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection keep-alive; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } listen 443 ssl; # managed by Certbot ssl_certificate /etc/letsencrypt/live/bet518.win/fullchain.pem; # managed by Certbot ssl_certificate_key /etc/letsencrypt/live/bet518.win/privkey.pem; # managed by Certbot include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot } server { if ($host = www.bet518.win) { return 301 https://$host$request_uri; } # managed by Certbot if ($host = bet518.win) { return 301 https://$host$request_uri; } # managed by Certbot listen 80; server_name localhost 104.199.230.207 bet518.win www.bet518.win; return 404; # managed by Certbot } 5. GitHub Pages 自定义域名支持 HTTPS 2018年5月1日，GitHub Pages 官方宣布 GitHub Pages 对自定义域名支持 HTTPS。 https://blog.github.com/2018-05-01-github-pages-custom-domains-https/ 什么，你问我为什么要GitHub Page使用HTTPS？简单来说，除了 HTTPS 自身带来的加密、防劫持等特性外，Github 官方基于 HTTPS 配合 CND，使得网站的加载速度更快，还能提供额外的防御 DDoS 攻击的保护。 GitHub官方文档已经说明了如何开启HTTPS。英文不熟悉的小伙伴看我下面的简单粗暴的讲解即可。 1）绑定域名 注册域名不多说。如何使用GitHub Pages中创建博客也不多说。废话完了，下面开始正题，以博主自己的账户为例(GitHub用户名为colin-chang) 解析域名 Github Pages 项目配置 打开 username.github.io 项目设置,并找到 GitHub Pages 模块的Custom domain填写自己的域名并点击 Save 在项目根目录新建一个名为 “CNAME” 的文件，内容为自己的域名 2）开启HTTPS 找到如下图所示的Enforce HTTPS选项并勾选。然后访问下自己的域名，不出意外的话，已经是https了。 那么如果如果之前已经开启了自定义域名， enforce HTTPS 无法勾选且怎么办？往下看... 把 Custom domain 中的值清空，并点击 Save 进行保存； 在 Custom domain 中的填入之前清空的值，填入后点击保存； 刷新项目设置页，如果 enforce HTTPS 可勾选，勾选即可； 如果 enforce HTTPS 不可勾选，并且提示 Not yet available for your site because the certificate has not finished being issued” ，说明证书尚未申请完成，等待一天即可。 完成以上步骤重新访问自己的域名，享受https吧开始 注意，如果使用仍然存在问题，请检查自己的网站引用的资源文件有没有使用了 http 协议，请替换成相应的 https 资源。 © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2018-12-12 00:45:21 "}}