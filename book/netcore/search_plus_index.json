{"./":{"url":"./","title":"前言","keywords":"","body":".Net Core .NET Core 是开放源代码通用开发平台，由 Microsoft 和 .NET 社区在 GitHub 上共同维护。 它跨平台（支持 Windows、macOS 和 Linux），并且可用于生成设备、云和 IoT 应用程序。 https://docs.microsoft.com/zh-cn/dotnet/core/about .NET Core 具有以下特性： 跨平台： 可以在 Windows、macOS 和 Linux 操作系统上运行。 跨体系结构保持一致： 在多个体系结构（包括 x64、x86 和 ARM）上以相同的行为运行代码。 命令行工具： 包括用于本地开发和持续集成方案中的易于使用的命令行工具。 部署灵活： 可以包含在应用或已安装的并行用户或计算机范围中。 可搭配 Docker 容器使用。 兼容性：.NET Core 通过 .NET Standard与 .NET Framework、Xamarin 和 Mono 兼容。 开放源：.NET Core 是一个开放源平台，使用 MIT 和 Apache 2 许可证。 .NET Core 是一个 .NET * oundation 项目。 由 Microsoft 支持：.NET Core 由 Microsoft 依据 .NET Core 支持提供支持。 © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2018-12-09 16:22:39 "},"pages/uninstall.html":{"url":"pages/uninstall.html","title":".Net Core 安装卸载","keywords":"","body":".Net Core 安装卸载 作为新一代微软高效跨平台技术，.Net Core自诞生以来就是跨平台的，目前支持Windows/mac OS/Linux平台。 Linux发行版众多，截止到写这篇文档时，.Net Core 2.2支持的Linux发行版如下： RHEL Ubuntu 18.04 Ubuntu 16.04 Ubuntu 14.04 Debian 9 Debian 8 Fedora 28 Fedora 27 CentOS / Oracle openSUSE Leap SLES 1. 安装 .Net Core的安装异常简单。到官网下载安装即可。Windows和Mac中都是下载安装包，双击运行安装，不再赘述。Linux选择对应的发行版本，执行官方的安装命令即可。 如果想体验最新版的.Net Core的特性，则可以到.Net Core的Github项目中下载。这里有.Net Core所有版本，包括历史版本和预览版本。 https://github.com/dotnet/core/tree/master/release-notes .Net Core安装包分为Runtime和SDK。如果只期望在平台上运行.Net Core程序，安装Runtime包即可。如果希望在平台上使用.Net Core的高级功能，如开发调试等，则需要安装SDK包。SDK包含了Runtime。 2. 卸载 .Net Core在Windows卸载非常简单，直接在控制面板中卸载即可。至于Mac和Linux环境下卸载就比较麻烦了。由于安装文件比较分散，所以删除和清理工作也比较繁琐，幸好.NET Foundation提供了卸载脚本。 #!/usr/bin/env bash # # Copyright (c) .NET Foundation and contributors. All rights reserved. # Licensed under the MIT license. See LICENSE file in the project root for full license information. # DIR=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" && pwd )\" current_userid=$(id -u) if [ $current_userid -ne 0 ]; then echo \"$(basename \"$0\") uninstallation script requires superuser privileges to run\" >&2 exit 1 fi # this is the common suffix for all the dotnet pkgs dotnet_pkg_name_suffix=\"com.microsoft.dotnet\" dotnet_install_root=\"/usr/local/share/dotnet\" dotnet_path_file=\"/etc/paths.d/dotnet\" remove_dotnet_pkgs(){ installed_pkgs=($(pkgutil --pkgs | grep $dotnet_pkg_name_suffix)) for i in \"${installed_pkgs[@]}\" do echo \"Removing dotnet component - \\\"$i\\\"\" >&2 pkgutil --force --forget \"$i\" done } remove_dotnet_pkgs [ \"$?\" -ne 0 ] && echo \"Failed to remove dotnet packages.\" >&2 && exit 1 echo \"Deleting install root - $dotnet_install_root\" >&2 rm -rf \"$dotnet_install_root\" rm -f \"$dotnet_path_file\" echo \"dotnet packages removal succeeded.\" >&2 exit 0 使用以上脚本卸载即可。 如果对shell脚本不熟悉的小伙伴也可以使用以下命令快速卸载，以mac为例， $ curl -o uninstall.sh https://gist.githubusercontent.com/colin-chang/1d8da588f399165924dc62dad42598d8/raw/50444ab4db30ab8d6205216dec0c3983333a5d6b/dotnet-uninstall-pkgs.sh $ chmod -R 740 uninstall.sh $ sudo sh uninstall.sh $ rm uninstall.sh © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2018-12-09 14:42:11 "},"pages/deploy.html":{"url":"pages/deploy.html","title":".Net Core 部署","keywords":"","body":".Net Core 部署 .Net Core程序可以部署在Windows/Linux/mac平台上。Mac较多的用于开发，鲜少用做服务器环境。下面我们以Asp.Net Core为例，简单梳理一下。 .net core程序无论是调试还是发布版本，都建议在程序目录下运行命令，否则可能会出现静态资源文件无法访问的问题。 1. Linux 在Linux中也可以使用 dotnet ./your_app.dll 方式在终端中运行.Net Core程序，但是退出终端后，程序就停止了。我们可以将运行命令封装到一个Linux服务中，服务器启动后就可以在后台静默运行了。 systemd 可用于创建服务文件以启动和监视基础 Web 应用。 systemd 是一个 init 系统，可以提供用于启动、停止和管理进程的许多强大的功能。 创建服务文件 $ sudo vi /etc/systemd/system/lottery.service 服务文件示例 [Unit] # 服务描述 Description=Lottery [Service] # 工作目录，此处为.net core程序目录 WorkingDirectory=/home/colin/apps/content/lottery # dotnet核心命令 ExecStart=/usr/bin/dotnet /home/colin/apps/content/lottery/Lottery.WebApp.dll # 重启策略 Restart=always RestartSec=10 # 日志标识 SyslogIdentifier=dotnet-lottery # 用户 User=colin # 环境变量 Environment=ASPNETCORE_ENVIRONMENT=Production Environment=DOTNET_PRINT_TELEMETRY_MESSAGE=false [Install] WantedBy=multi-user.target 服务管理 # 启用服务 $ sudo systemctl enable kestrel-lottery.service # 启动服务 $ sudo systemctl start kestrel-lottery.service # 查看服务状态 $ sudo systemctl status kestrel-lottery.service # 停止服务 $ sudo systemctl stop kestrel-lottery.service # 重启服务 $ sudo systemctl restart kestrel-lottery.service 完成以上步骤之后，Asp.Net Core程序已经挂载到了Kestrel服务器上并以Linux服务方式后台静默运行。虽然Kestrel服务器对Asp.Net支持非常好，但微软不建议其作为对外服务器，而是建议使用IIS/Nginx/Apache等作为代理服务器对外开放。 关于Linux下Nginx部署，参阅： http://colin-chang.site/book/linux/part2/nginx.html https://docs.microsoft.com/zh-cn/aspnet/core/host-and-deploy/linux-nginx?view=aspnetcore-2.2 Apache配置，参阅： https://docs.microsoft.com/zh-cn/aspnet/core/host-and-deploy/linux-apache?view=aspnetcore-2.2 2. Windows Windows 下.Net Core部署参阅： https://docs.microsoft.com/zh-cn/aspnet/core/host-and-deploy/iis/?view=aspnetcore-2.2 © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2018-12-09 15:42:57 "},"pages/dapper.html":{"url":"pages/dapper.html","title":"Dapper","keywords":"","body":"Dapper 全攻略 1. 简介 2. 项目/模型 3. CRUD 4. 其他 5. Dapper Plus 1. 简介 Dapper是.NET下一个轻量级的ORM框架，它和Entity Framework或Nhibnate不同，属于轻量级的，并且是半自动的。也就是说实体类都要自己写。它没有复杂的配置文件，一个单文件就可以了。Dapper通过提供IDbConnection扩展方法来进行工作。 Dapper没有定义特定的数据库要求，它支持所有ADO.NET支持的数据库，如SQLite,SQL CE,Firebird,Oracle,MySQL,PostgreSQL,SQL Server等。 国外知名网站Stack Overflow生产环境使用Dapper进行数据库访问。 2. 项目/模型 下面我们通过一个简单的.Net Core控制台项目来快速入门Dappper使用。数据库使用MySQL。 2.1 创建项目 # 创建.net core控制台项目 $ dotnet new console -n DapperDemo # 引用Dapper和MySQL nuget包 $ dotnet add package Dapper $ dotnet add package MySql.Data 2.2 数据模型 1) 数据库 CREATE TABLE `article` ( `Id` int(11) NOT NULL AUTO_INCREMENT, `Title` varchar(255) NOT NULL, `Content` text NOT NULL, `Status` int(1) NOT NULL DEFAULT '1', `UpdateTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP, `AuthorId` int(11) NOT NULL, PRIMARY KEY (`Id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `author` ( `Id` int(11) NOT NULL AUTO_INCREMENT, `NickName` varchar(255) NOT NULL, `RealName` varchar(255) NOT NULL, `BirthDate` date DEFAULT NULL, `Address` varchar(255) DEFAULT NULL, PRIMARY KEY (`Id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `comment` ( `Id` int(11) NOT NULL AUTO_INCREMENT, `ArticleId` int(11) NOT NULL, `Content` varchar(255) NOT NULL, `CreateTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`Id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 2) 数据模型 public abstract class BaseModel { public int Id { get; set; } } public class Author : BaseModel { public string NickName { get; set; } public string RealName { get; set; } public DateTime? BirthDate { get; set; } public string Address { get; set; } public Author() { } public Author(string nickName, string realName) { NickName = nickName; RealName = realName; } } public class Article : BaseModel { public string Title { get; set; } public string Content { get; set; } public ArticleStatus Status { get; set; } public DateTime UpdateTime { get; set; } public int AuthorId { get; set; } public Author Author { get; set; } public IEnumerable Comments { get; set; } } public class Comment : BaseModel { public int ArticleId { get; set; } public Article Article { get; set; } public string Content { get; set; } public DateTime CreateTime { get; set; } } public enum ArticleStatus { Abnormal, Normal } 3. CRUD 建立数据库连接。 private static readonly string _connStr; private static IDbConnection Cnn => new MySqlConnection(_connStr); static DapperPlus() { _connStr = \"Server=127.0.0.1;Database=db_dapper;Uid=root;Pwd=xxxxxx;\"; } 3.1 非查询操作 1) 插入数据 Dapper可以使用同样的方式插入一条或多条数据。 string sql = \"INSERT INTO author (NickName,RealName) VALUES(@nickName,@RealName)\"; var colin = new Author(\"Colin\", \"Colin Chang\"); var robin = new Author(\"Robin\", \"Robin Song\"); using (var cnn = Cnn) { await cnnExecuteAsync(sql, new Author[] { colin, robin }); } 2) 更新数据 string sql = \"UPDATE author SET Address=@address WHERE Id=@id\"; using (var cnn = Cnn) { await cnnExecuteAsync(sql, new { id = 1, address = \"山东\" }); } 3) 删除数据 string sql = \"DELETE FROM author WHERE Id=@id\"; using (var cnn = Cnn) { await cnnExecuteAsync(sql,new {id=2}); } 3.2 查询操作 1) 简单查询 var sql = \"SELECT * FROM author WHERE Id=@id\"; using (var cnn = Cnn) { var authors = await cnnQueryAsync(sql, new { id = 1 }); } 常用的IN ()方式查询 var sql = \"SELECT * FROM author WHERE Id IN @ids\"; using (var cnn = Cnn) { var authors = await cnnQueryAsync(sql, new { ids = new int[] { 1, 2 } }); } 2) 多表连接查询 此处演示使用三表连接查询，同时包含1:1和1:N的关系。 var sql = @\"SELECT * FROM article AS ar JOIN author AS au ON ar.AuthorId = au.Id LEFT JOIN `comment` AS c ON ar.Id = c.ArticleId\"; var articles = new Dictionary(); using (var cnn = Cnn) { var data = await cnnQueryAsync(sql, (article, author, comment) => { //1:1 article.Author=author; //1:N if (!articles.TryGetValue(article.Id, out Article articleEntry)) { articleEntry = article; articleEntry.Comments = new List{}; articles.Add(article.Id, articleEntry); } articleEntry.Comments.Add(comment); return articleEntry; }); // var result= data.Distinct(); } var result = articles.Values; //data.Distinct()和articles.Values都可以拿到数据，且数据内容相同。 1:N关系的连接查，查询出来的数据都是连接展开之后的全部数据记录，以上代码中的Lambda表达式会在遍历没条数据记录时执行一次。 3) 多结果集查询 Dapper支持多结果集查询，可以执行任意多条查询语句。 // 多结果集查询 string sqls = @\" SELECT * FROM article WHERE Id=@id; SELECT * FROM `comment` WHERE ArticleId=@articleId;\"; using (var cnn = Cnn) { var reader = await cnnQueryMultipleAsync(sqls, new { id = 1, articleId = 1 }); var articles = await reader.ReadAsync(); var comments= await reader.ReadAsync(); var article = articles.FirstOrDefault(); if (article != null) article.Comments = comments; } 多结果集查询中，配合使用多条存在一定关联关系的查询语句，可以在一定程上巧妙的实现连接查询的效果，避免多表连接查询锁表的问题。以上代码即实现了此种效果。 3. 事务和存储过程 3.1 事务 var scripts = new SqlScript[] { new SqlScript(\"UPDATE article SET UpdateTime=NOW() WHERE Id=@id\",new {id=2}), new SqlScript(\"UPDATE author SET BirthDate=NOW() WHERE Id=@id\",new {id=1}) } using (var cnn = Cnn) { IDbTransaction tran = null; try { cnnOpen(); tran = cnnBeginTransaction(); foreach (var script in scripts) await cnnExecuteAsync(script.Sql, script.Param, tran, commandType: script.CommandType); tran.Commit(); } catch { tran?.Rollback(); } } 以上演示用到的脚本模型类如下： public class SqlScript { public string Sql { get; set; } public object Param { get; set; } public CommandType CommandType { get; set; } public SqlScript(string sql, object param = null, CommandType cmdType = CommandType.Text) { Sql = sql; Param = param; CommandType = cmdType; } } 3.2 存储过程 Dapper完全支持存储过程。存储过程比较简单，代码就不展示了，读者可以自己按照自己想法随意创建。 using (var cnn = Cnn) { var users = cnnQuery(\"spGetAuthors\", new {Id = 1}, commandType: CommandType.StoredProcedure); } 使用传入传出参数的存储过程。 var p = new DynamicParameters(); p.Add(\"@a\", 11); p.Add(\"@b\", dbType: DbType.Int32, direction: ParameterDirection.Output); p.Add(\"@c\", dbType: DbType.Int32, direction: ParameterDirection.ReturnValue); using (var cnn = Cnn) { cnnExecute(\"spMagicProc\", p, commandType: CommandType.StoredProcedure); } int b = p.Get(\"@b\"); int c = p.Get(\"@c\"); 4. 其他 4.1 参数替换 Dapper支持对SQL语句中bool和数字类型进行替换。 var sql = \"SELECT * FROM article WHERE Status= {=Normal}\"; using (var cnn = Cnn) { var articles = await cnnQueryAsync(sql, new {ArticleStatus.Normal}); } 参数替换在特定类型字段中非常好用，比如\"category id\", \"status code\" or \"region\" 参数替换并非采用参数话查询，虽然使用方便但是建议经过测试后谨慎使用。 4.2 缓存查询 默认情况下Dapper会对执行SQL后的整个reader进行缓存，以减少数据库锁定和网络请求时间。然而执行大批量查询操作时缓存会占用大量内存空间，此时执行查询操作可以设置buffered: false 以禁用缓存。 4.3 ANSI编码 Dapper支持varchar类型参数,如果查询语句需要过滤一个varchar类型的字段可以使用以下方式指定编码: Query(\"select * from Author where Address = @address\", new {address = new DbString { Value = \"山东\", IsFixedLength = true, Length = 10, IsAnsi = true }); SQL Server中查询unicode and ANSI字段时务必使用unicode编码 4.4 多数据类型行 某些情况下同一行数据的某个字段可以是不同的数据类型。这种情况使用IDataReader.GetRowParser非常方便。 有shapes表结构如上图，我们可以根据Type字段将每行数据映射为Circle,Square,Triangle等具体类型对象。以下为示例代码： var shapes = new List(); using (var reader = connection.ExecuteReader(\"select * from Shapes\")) { // Generate a row parser for each type you expect. // The generic type is what the parser will return. // The argument (typeof(*)) is the concrete type to parse. var circleParser = reader.GetRowParser(typeof(Circle)); var squareParser = reader.GetRowParser(typeof(Square)); var triangleParser = reader.GetRowParser(typeof(Triangle)); var typeColumnIndex = reader.GetOrdinal(\"Type\"); while (reader.Read()) { IShape shape; var type = (ShapeType)reader.GetInt32(typeColumnIndex); switch (type) { case ShapeType.Circle: shape = circleParser(reader); break; case ShapeType.Square: shape = squareParser(reader); break; case ShapeType.Triangle: shape = triangleParser(reader); break; default: throw new NotImplementedException(); } shapes.Add(shape); } } 5. Dapper Plus Dapper仅提供了SqlHelper常用功能和对象映射，我们通常会对Dapper进行二次封装扩展以更方便的使用Dapper。 Dapper Plus扩展在无损Dapper性能的前提下，基本覆盖了日常数据操作。 Dapper Plus包含了上面的所有数据操作，案例中的代码已经包含在单元测试项目中。 源码地址：https://github.com/colin-chang/dapper-plus © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2018-12-08 19:55:21 "}}