{"./":{"url":"./","title":"分布式概述","keywords":"","body":"分布式架构 关于大型系统的分布式架构在网上存在着大量的相关资料，在不同的技术栈中又存在这些许的差异，但究其根本整体的思路是大同小异的。我们就此以.net平台为例，对分布式架构的演化过程做一个简单的梳理。 首先说明以下内容是基于普遍化的通用系统而不是做并行数据库等基础服务，因此在Hadoop、Spark、ZooKeeper、dubbo等我们暂不考虑。 1. 一台服务器 最初假设的系统中，我们把应用系统、文件和数据库都放在一台服务器上，一台服务器包打天下。 2. 不同服务器 随着业务扩展，一台服务器无法满足性能需求，此时我们考虑将应用系统、数据库、文件分别部署在不同的服务器上，并根据服务器用途不同，配置不同的硬件，达到性能最佳的效果。 3. 服务器集群 随着业务扩展，一台应用系统、数据库、文件服务器性能无法承载大量数据处理、高并发用户访问时，必须考虑采用集群方式。 3.1 应用服务器集群+负载均衡服务器集群 应用系统服务器作为网站的入口，会承担大量的请求，我们往往通过应用服务器集群来分担请求数。 应用服务器前面需要部署负载均衡服务器调度用户请求，根据分发策略将请求分发到多个应用服务器节点。以下为常用的负载均衡技术 硬件的有F5，价格比较贵， 软件的有LVS、Nginx、HAProxy等。 3.2 数据库集群和优化 随着用户量的增加，数据库成为最大的瓶颈，改善数据库性能常用的手段是进行读写分离以及分表，读写分离顾名思义就是将数据库分为读库和写库，通过主备功能实现数据同步。分库分表则分为水平切分和垂直切分，水平切换则是对一个数据库特大的表进行拆分，例如订单、物流信息表等。垂直切分则是根据业务不同来切换，如订单、计税等等不同的主题放在不同的数据库中。这种情况下，关联查询是没有的，通过程序可以比较容易的去解决，还有就是采用分布式事务，来保证数据的一致性。我们这里还有一个做法，一个大的数据表拆分为当前操作表和历史记录表， 当前操作表只保留正在操作的数据，完成后转入历史记录表，这样可以提高当前操作数据的效率。 3.3 文件服务器集群 用户一天天增加，业务量越来越大，产生的文件越来越多。通常情况下，一个目录下的文件建议不能超过1万个，否则对于文件的查找和轮询都会非常慢，会导致整个系统无法正常运行。我们一般是按照\"\\应用程序名\\模块名称\\日期\"的目录结构组织的，对于文件数目仍旧很大的应用，应该再细分。当单台的文件服务器已经不能满足需求，就需要分布式的文件系统支撑。常用的分布式文件系统有NFS。我们用的是MS的分布式文件系统（DFS），与AD域相关性较大。 3.4 分布式缓存服务器集群 因为应用服务器是集群方式，用户前后两次请求可能访问的不是一台服务器。因此已经不能像以前一样使用状态（Application、Session、Cache、ViewState等），应用系统必须是无状态的（当然了，用的负载均衡具有会话保持的时候，一个用户只会定位到一台服务器）。系统的缓存应该保存在专门的缓存服务器上，如果必须有状态，也应该保存在专门的缓存服务器中。作为第一批吃螃蟹者，我们用了微软的AppFabric作为缓存服务器，因为当时版本很低，问题也不少，后来我们弃用了AppFabric，使用Redis作为缓存服务。现在，AppFabric已经改进了不少，运行在Azure云上，应该是不会存在以前的问题了。 对于各种政府、单位等不能将系统部署到互联网的部门，并且在各省、市都有对应的分支机构。因为网络专线的价格还是比较高的，至少比互联网的网络带宽低了不少，当然了不差钱的不说啊。这种情况下，一般不采用如上的集中式、集群部署方式，而是采用分布式部署的方式，第一种分布式部署是各分支机构搭建一整套系统，定期（例如每天）进行数据的同步工作，将分支数据汇总到总部、总部的数据下发回各分部；第二种分布式部署方式是各分支部署中间件，但是数据集中在总部。 4. 应用水平拆分+消息队列 随着业务进一步扩展，应用程序变得非常臃肿，这时我们需要将应用程序进行业务拆分，如我们做的综合业务管理系统分为门户、联系处置、业务信息、指标、数据查询分析等业务板块。每个业务板块是一个独立的应用负责相对独立的业务运作。业务板块之间通过消息队列进行通信来实现。数据库也进行相应的拆分，不同的主题放到不同的数据库中。同时，最好搭建静态资源服务器，将公用的css、js、images等都存放到静态资源服务器中。 5. NoSQL+搜索引擎服务 对于海量数据的查询，我们使用nosql数据库加上搜索引擎可以达到更好的性能。并不是所有的数据都要放在关系型数据中。常用的NOSQL有mongodb和redis，搜索引擎有lucene，我们使用的Solr、ElasticSearch等基于Lucene内核实现的更易用的搜索引擎。数据量大的话，Solr等也要做成集群。 六、再往下走，系统需要与其他系统进行交互，系统也要给各种前端（例如网站、安卓、IOS）提供服务，这样我们就要在逻辑层之上建设应用服务层，提供对客户端的和对外的SOA服务接口。这样又涉及到DTO、WebService、WCF和WebApi（Rest）等概念。但是最重要的是，SOA方式下，包括前面的MQ方式下，事务一致性无法得到保障的，必须采用一定的机制例如事务补偿机制来确保事务的最终一致性。各个业务板块所在的服务器，在不同时段的压力也不同，为了尽量做到服务器集群内各服务器的压力平摊， 还需要提供更好的机制，记录下每个服务器的压力、资源情况、连接数等等，以便将新的请求转向到压力最小的服务器上。 七、业务继续发展，就是CDN，再往下就是搭建几个中心，将系统部署在各个中心，各地用户访问距离他最近的中心，中心间数据保持同步。 八、上面讲了应用系统方面比较多，数据方面也要做许多工作。上面已经介绍了分库分表方式。应用系统做大了，势必有许多的数据资源，尤其是现在大数据这个名词非常火爆的情况下，数据分析和处理是一个系统必须要做的事情。这样做的好处是，将数据的查询、分析等独立出来，不影响正式运行中的系统，另外是通过分析挖掘确实能得到许多意想不到的价值。 这时，主要的工作是搭建数据仓库，然后进行后续的分析和处理。使用ETL/ELT将数据定期从正式环境中导入到数据仓库中，按照不同的主题搭建一个个的数据集市。对于数据量比较小的系统，可以使用关系数据库+多维数据库的方式；对于大型系统，就要使用按列存储、并行数据库等方式了。对于数据的分析可以以报表、KPI、仪表盘驾驶舱等方式提供上层领导决策，也可以使用数据挖掘、机器学习和训练等方式实现价值发现、风险控制等。 九、一般情况下，企业是没有那么大的财力和人员去做上述内容的，因此使用云成为企业的一个选择。无论是Azure、阿里云、亚马逊等都会提供一个个的服务。我们就以阿里云为例，ECS提供虚拟服务器、SLB提供负载均衡、RDS提供数据库服务、OSS提供存储服务、DRDS是分布式数据服务、ODSP（现在改名叫MaxCompute）提供大数据的计算服务、RocketMQ提供MQ、OCS提供分布式缓存服务、以及CDN、OTS、ADS等等就不一一列举了。 对了，现在还有Docker这个利器，无论在企业还是云中都可以使用，我们在自己内部使用的Redis、Memcached、RabbitMQ、Solr等都部署在Docker中，确实比较方便。 上面说了一大堆，其实架构做的再好，还需要底层来实现。目前流行的语言还是面向对象OO的Java、.net等，也就是说还是用OO的思想和理念去编程。抽象、封装、继承、多态尽管很字面上比较容易理解，但是深入的认识确实需要一定的程序量的积累，面向对象的几大原则和设计模式还是编写出更高可扩展、可替换、可配置、可维护等软件质量指标的代码的重要保证。 © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2018-11-12 18:53:22 "},"pages/mq.html":{"url":"pages/mq.html","title":"1 消息队列","keywords":"","body":"消息队列 © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2018-11-12 18:13:51 "},"pages/exceptionless.html":{"url":"pages/exceptionless.html","title":"2 分布式异常日志框架","keywords":"","body":"免费开源分布式系统日志收集框架 Exceptionless 1. 简介 2. 简单使用 3. 进阶使用 4. 异常日志模块封装 5. 本地部署 1. 简介 Exceptionless 是一个开源的实时的日志收集框架，它可以应用在基于 ASP.NET，ASP.NET Core，Web Api，Web Forms，WPF，Console，MVC 等技术栈的应用程序中，并且提供了Rest接口可以应用在 Javascript，Node.js 中。它将日志收集变得简单易用并且不需要了解太多的相关技术细节及配置。 在以前，我们做日志收集大多使用 Log4net，Nlog 等框架，在应用程序变得复杂并且集群的时候，可能传统的方式已经不是很好的适用了，因为收集各个日志并且分析他们将变得麻烦而且浪费时间。 现在Exceptionless团队给我们提供了一个更好的框架来做这件事情，我认为这是非常伟大并且有意义的，感谢他们。 官网：http://exceptionless.com/ GitHub：https://github.com/exceptionless/Exceptionless 两种使用方式 官网创建帐号，并新建应用程序以及项目，然后生成apikey（数据存储在Exceptionless） 自己搭建Exceptionless的环境，部署在本地（数据存储在本地） 2. 简单使用 1) 注册账号 首先，需要去官网注册一个帐号（打不开的同学你懂的），注册完成之后登录系统。 2) 新建项目 按照提示，添加一个项目。 选择项目的类型，可以看到 Exceptionless支持很多种项目。我们来选择一个 ASP.NET Core 的项目。 完成后可以看到一个详细步骤说明如何在项目中集成。 3) 项目集成 首先，使用 NuGet 添加一个包，名字叫Exceptionless.AspNetCore。 在 ASP.NET Core 项目中，打开startup.cs文件，找到Configure()方法，添加如下： using Exceptionless; ...... public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory) { // xxxxx 处填写上图画红线部分的key app.UseExceptionless(\"xxxxxxxxxxxxxxxxxxxxxxxxxx\"); app.UseMvc(); } 至此，Exceptionless 已经可以在你的项目中工作了，它会自动记录项目中的异常情况。 4) 查看异常 创建一个 ASP.NET Core 项目，然后通过下面方式直接抛出一个异常，下面我们来运行一下，看看它是怎么工作的吧。 public IActionResult About() { throw new Exception(\"test exception\"); return View(); } 接下来，刷新 Exceptionless的页面，在 Dashboard 主面板中，可以看到关于整个项目的一个异常情况，并且分别以几种方式列了出来，其中包括分布图，最频繁的异常，最近的异常等等。 这个我们刚才在Abount Action中制造的一个异常，Exceptionless已经记录了下来，点进去之后可以看一下详情。 除了一些基本的异常类型、时间和堆栈外，Request和Enviroment中还包括访问者的坐标、IP地址、发生异常的URL地址、浏览器信息，操作系统、甚至发生异常时请求的Cookie值。 3. 进阶使用 3.1 发送事件 除了我们所熟悉的异常信息外，Exceptionless 还可以记录很多种类的其他信息，这些信息统称做事件(Event)。 在Exceptionless 中，有这几类事件： Log （日志）、Feature Usages（功能用途）、404、Custom Event（自定义事件）。 Exceptionless 中发送不同类型事件很简单，代码如下： using Exceptionless; // 发送日志 ExceptionlessClient.Default.SubmitLog(\"Logging made easy\"); // 你可以指定日志来源，和日志级别。 // 日志级别有这几种: Trace, Debug, Info, Warn, Error ExceptionlessClient.Default.SubmitLog(typeof(Program).FullName, \"This is so easy\", \"Info\"); ExceptionlessClient.Default.CreateLog(typeof(Program).FullName, \"This is so easy\", \"Info\").AddTags(\"Exceptionless\").Submit(); // 发送 Feature Usages ExceptionlessClient.Default.SubmitFeatureUsage(\"MyFeature\"); ExceptionlessClient.Default.CreateFeatureUsage(\"MyFeature\").AddTags(\"Exceptionless\").Submit(); // 发送一个 404 ExceptionlessClient.Default.SubmitNotFound(\"/somepage\"); ExceptionlessClient.Default.CreateNotFound(\"/somepage\").AddTags(\"Exceptionless\").Submit(); // 发生一个自定义事件 ExceptionlessClient.Default.SubmitEvent(new Event { Message = \"Low Fuel\", Type = \"racecar\", Source = \"Fuel System\" }); 3.2 手动发送异常 有时候，我们在程序代码中显式的处理一些异常，这个时候可以手动的来将一些异常信息发送到Exceptionless。 try { throw new ApplicationException(Guid.NewGuid().ToString()); } catch (Exception ex) { ex.ToExceptionless().Submit(); } 3.3 附加标记 当然你还可以为发送的事件添加额外的标记信息，比如坐标，标签，以及其他的用户相关的信息等。 try { throw new ApplicationException(\"Unable to create order from quote.\"); } catch (Exception ex) { ex.ToExceptionless() // 为事件设定一个编号，以便于你搜索 .SetReferenceId(Guid.NewGuid().ToString(\"N\")) // 添加一个不包含CreditCardNumber属性的对象信息 .AddObject(order, \"Order\", excludedPropertyNames: new [] { \"CreditCardNumber\" }, maxDepth: 2) // 设置一个名为\"Quote\"的编号 .SetProperty(\"Quote\", 123) // 添加一个名为“Order”的标签 .AddTags(\"Order\") // 标记为关键异常 .MarkAsCritical() // 设置一个地理位置坐标 .SetGeo(43.595089, -88.444602) // 设置触发异常的用户信息 .SetUserIdentity(user.Id, user.FullName) // 设置触发用户的一些描述 .SetUserDescription(user.EmailAddress, \"I tried creating an order from my saved quote.\") // 发送事件 .Submit(); } 3.4 统一处理发送的事件 可以在通过SubmittingEvent 事件设置全局的忽略异常信息添加一些自定义信息等。 #region Exceptionless配置 ExceptionlessClient.Default.Configuration.ApiKey = exceptionlessOptions.Value.ApiKey; ExceptionlessClient.Default.Configuration.ServerUrl = exceptionlessOptions.Value.ServerUrl; ExceptionlessClient.Default.SubmittingEvent += OnSubmittingEvent; app.UseExceptionless(); #endregion /// /// 全局配置Exceptionless /// /// /// private void OnSubmittingEvent(object sender, EventSubmittingEventArgs e) { // 只处理未处理的异常 if (!e.IsUnhandledError) return; // 忽略404错误 if (e.Event.IsNotFound()) { e.Cancel = true; return; } // 忽略没有错误体的错误 var error = e.Event.GetError(); if (error == null) return; // 忽略 401 (Unauthorized) 和 请求验证的错误. if (error.Code == \"401\" || error.Type == \"System.Web.HttpRequestValidationException\") { e.Cancel = true; return; } // Ignore any exceptions that were not thrown by our code. var handledNamespaces = new List { \"Exceptionless\" }; if (!error.StackTrace.Select(s => s.DeclaringNamespace).Distinct().Any(ns => handledNamespaces.Any(ns.Contains))) { e.Cancel = true; return; } // 添加附加信息. //e.Event.AddObject(order, \"Order\", excludedPropertyNames: new[] { \"CreditCardNumber\" }, maxDepth: 2); e.Event.Tags.Add(\"MunicipalPublicCenter.BusinessApi\"); e.Event.MarkAsCritical(); //e.Event.SetUserIdentity(); } 3.5 配合使用 NLog 或 Log4Net 配合使用 NLog 或 Log4Net 有时候，程序中需要对日志信息做非常详细的记录，比如在开发阶段。这个时候可以配合 log4net 或者 nlog 来联合使用 exceptionless，详细可以查看这个官方的 [示例][https://github.com/exceptionless/Exceptionless.Net/tree/master/samples/Exceptionless.SampleConsole]。 如果你的程序中有在短时间内生成大量日志的情况，比如一分钟产生上千的日志。这个时候你需要使用内存存储（in-memory store）事件，这样客户端就不会将事件系列化的磁盘，所以会快很多。这样就可以使用Log4net 或者 Nlog来将一些事件存储到磁盘，另外 Exceptionless 事件存储到内存当中。 using Exceptionless; ExceptionlessClient.Default.Configuration.UseInMemoryStorage(); 4. 异常日志模块封装 下面是实际项目(Asp.Net Core)中使用Exceptionless异常日志模块的简单封装。 简单说明下。在项目中许多可以预料的异常，如文件IO，网络请求等，这些异常我们一般都会通过try...catch...方式捕获，由于此类异常属于预料中异常，我们只记录日志(Exceptionless Log)即可。对于程序中出现的未处理异常则属于预料之外的错误，比如编写代码时的逻辑错误等，此类异常我们通过全局异常过滤器捕捉到并发送到Exceptionless的异常中。 其异常严重程度链如下： TraceLog/OtherLog 4.1 异常日志模块 using System; using Exceptionless; using Exceptionless.Logging; public static class ExceptionlessUtil { public static void Trace(string message) { Trace(new Exception(message)); } public static void Trace(Exception ex, string title = null, bool traceException = false) { TraceLog(ex, LogLevel.Trace, title, traceException); } public static void Debug(string message) { Debug(new Exception(message)); } public static void Debug(Exception ex, string title = null, bool traceException = false) { TraceLog(ex, LogLevel.Debug, title, traceException); } public static void Info(string message) { Info(new Exception(message)); } public static void Info(Exception ex, string title = null, bool traceException = false) { TraceLog(ex, LogLevel.Info, title, traceException); } public static void Warn(string message) { Warn(new Exception(message)); } public static void Warn(Exception ex, string title = null, bool traceException = false) { TraceLog(ex, LogLevel.Warn, title, traceException); } public static void Error(string message) { Error(new Exception(message)); } public static void Error(Exception ex, string title = null, bool traceException = false) { TraceLog(ex, LogLevel.Error, title, traceException); } public static void Fatal(string message) { Fatal(new Exception(message)); } public static void Fatal(Exception ex, string title = null, bool traceException = false) { TraceLog(ex, LogLevel.Fatal, title, traceException); } public static void Other(string message) { Other(new Exception(message)); } public static void Other(Exception ex, string title = null, bool traceException = false) { TraceLog(ex, LogLevel.Other, title, traceException); } /// /// 记录Log /// /// 异常 /// 日志级别 /// 是否追踪异常。true则提交Exception,否则只提交Log public static void TraceLog(Exception ex, LogLevel logLevel, string title = null, bool traceException = false) { ExceptionlessClient.Default.CreateLog(ex.TargetSite.GetType().FullName, string.IsNullOrWhiteSpace(title) ? string.Empty : $\"{title},错误消息:\" + ex.Message, logLevel) .AddTags(ex.GetType().FullName).Submit(); if (traceException) TraceException(ex); } /// /// 追踪Exception /// /// public static void TraceException(Exception ex) { ex.ToExceptionless().Submit(); } } 4.2 异常日志记录 1) 异常过滤 /// /// 全局异常过滤器 /// public class GlobalExceptionFilter:IExceptionFilter { public void OnException(ExceptionContext context) { //提交异常信息 ExceptionlessUtil.TraceException(context.Exception); //转到错误页面 context.Result = new RedirectResult(\"/error\"); context.HttpContext.Response.StatusCode = (int)HttpStatusCode.InternalServerError; //标记已处理 context.ExceptionHandled = true; } } // Startup.cs的ConfigureServices中注册filter services.AddMvc(options => options.Filters.Add()) 此项目采用Asp.Net Core技术栈，引用的Exceptionless包为Exceptionless.AspNetCore,UnhandledException通过对filter进行处理。其他类型的项目可以引用对应的nuget包，作相应的UnhandledException处理即可。 2) 日记记录 private async Task RequestAsync(string url, object parameter, string method) { try { // 执行网络请求 ... } catch (Exception ex) { ExceptionlessUtil.Warn(ex, $\"网络请求出错{url}\"); return null; } } 5. 本地部署 如果不想使用Exceptionless官网提供服务，也可以在本地部署服务器。部署步骤参考 https://github.com/exceptionless/Exceptionless/wiki/Self-Hosting Exceptionless 官方文档 https://github.com/exceptionless/Exceptionless/wiki/Getting-Started © Colin Chang all right reserved，powered by Gitbook文件修订时间： 2018-11-29 21:53:21 "}}